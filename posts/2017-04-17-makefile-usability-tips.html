<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" media="all" href="/css/app.css"><link rel="alternate" type="application/rss+xml" title="{ blog: david mosher }" href="/index.xml"><title>{ blog: david mosher } | Makefile Usability Tips</title></head><body class="theme-"><div id="wrap"><header><a href="/">{ blog: david mosher }</a><span class="description">thoughts on software, music, design, and meaning</span></header><nav><ul><li><a href="/">homepage</a></li><li><a href="/archive.html">archive</a></li></ul><div id="older-newer"><div class="newer"><a href="/posts/2017-11-07-react-performance-analysis.html">newer</a></div><div class="older"><a href="/posts/2017-03-07-advanced-directives-with-angular-js-part-2.html">older</a></div></div></nav><article><h1><a href="/posts/2017-04-17-makefile-usability-tips.html" title="Permanent link to ‘Makefile Usability Tips’">Makefile Usability Tips</a></h1><h6><time datetime="2017-04-17">April 17th, 2017</time></h6><aside class="tldr">
You can improve the DX of Makefiles using some simple target annotations and some parsing with <code>grep</code> and <code>awk</code>.
</aside>

<p>It has been but a <a href="/build-automation-holy-war.png">few short years</a> since <em>web developers</em> chose a side and took up arms in the holy war of <a href="https://en.wikipedia.org/wiki/Make_(software)">build automation tools</a>; this is only one of <a href="https://en.wikipedia.org/wiki/Editor_war">many</a> <a href="https://en.wikipedia.org/wiki/Browser_wars">wars</a> that have been fought <a href="https://en.wikipedia.org/wiki/Indent_style">countless times</a> since the dawn of computing. In the grim darkness of the far future, there is only war.</p>
<p>Meh. War is tiresome and I have had enough of war. This post is about some small usability improvements you can add to your Makefiles if you are using Make. Let’s dig in!</p>
<h2 id="the-makefile">The Makefile</h2>
<p>Make has been around for a <a href="https://en.wikipedia.org/wiki/Make_(software)">long time</a>. It has some neat features but it’s not always the friendliest to neophytes. Imagine you have a new developer joining your team, and your project has a Makefile that looks something like this</p>
<pre><code class="hljs language-Makefile">VERSION ?= <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> cat VERSION)</span>

<span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: version clean bump release</span>

<span class="hljs-section">build:</span>
  @echo <span class="hljs-string">&quot;building...&quot;</span>
  <span class="hljs-comment"># build the app here</span>

<span class="hljs-section">clean:</span>
  <span class="hljs-comment"># rm -rf build</span>

<span class="hljs-section">release:</span>
  <span class="hljs-comment"># bump</span>
  <span class="hljs-comment"># make push -e VERSION=$(shell cat VERSION)</span>

<span class="hljs-section">push:</span>
  <span class="hljs-comment"># push the build artifact at a given version somewhere</span>

<span class="hljs-section">version:</span>
  <span class="hljs-comment"># cat VERSION</span>

<span class="hljs-section">bump:</span>
  <span class="hljs-comment"># using semver, bump the version by a major, minor or patch increment</span>
</code></pre>
<p>At first glance this Makefile isn’t all that complicated but chances are your build automation process is composed of many more lines of code or even split into multiple places. The wise aged veteran developer on your team tells the new member “to build this project just clone this repo and run <code>make</code>“ after which the new developer sees</p>
<pre><code class="hljs language-shell">neophyte@newbie:~/code/project
<span class="hljs-meta">$ </span><span class="language-bash">make</span>
building...
</code></pre>
<p>Now, assuming new dev didn’t encounter any snags with project setup and installing dependencies (hah! unlikely) this still doesn’t present a great picture of how the project is assembled or the bits of the lifecycle that are involved at first glance. Let’s see if we can improve this initial Makefile developer experience.</p>
<h3 id="step-1-add-a-default_goal">Step 1: Add a DEFAULT_GOAL</h3>
<p>In Make semantics, <em>goals</em> are targets that <code>make</code> should strive to update. The docs give us a nice <a href="https://www.gnu.org/software/make/manual/html_node/Goals.html">explanation of goals</a> as well as some hints about how we can manage which goal is run first</p>
<blockquote>
<p>By default, the goal is the first target in the makefile (not counting targets that start with a period). Therefore, makefiles are usually written so that the first target is for compiling the entire program or programs they describe. If the first rule in the makefile has several targets, only the first target in the rule becomes the default goal, not the whole list. You can manage the selection of the default goal from within your makefile using the .DEFAULT_GOAL variable (see <a href="https://www.gnu.org/software/make/manual/html_node/Special-Variables.html#Special-Variables">Other Special Variables</a>).</p>
</blockquote>
<p>Even though the docs give us some informal conventions about the first target in our Makefile I think it <em>makes</em> (heh) for a better experience if we add some sort of help target that spits out some information to the terminal. Make doesn’t have any facility to display help messages like some <a href="https://rake.rubyforge.org/Rake/Application.html">other build automation tools</a>, but it won’t be too hard to add one. First, let’s add a default goal of help</p>
<pre><code class="hljs language-Makefile">.DEFAULT_GOAL := help

<span class="hljs-section">help:</span>
  @echo <span class="hljs-string">&quot;Welcome to the Project!&quot;</span>
</code></pre>
<caption>
  <strong>Tip:</strong> prefixing a line in your make target with `@` suppresses output of that line to stdout.
</caption>

<p>With this in place our new developer sees the following</p>
<pre><code class="hljs language-shell">neophyte@newbie:~/code/project
<span class="hljs-meta">$ </span><span class="language-bash">make</span>
Welcome to the Project!
</code></pre>
<p>Ok, this is a little more friendly but still not very useful. We can do better!</p>
<h3 id="step-2-annotate-makefile-targets">Step 2: Annotate Makefile Targets</h3>
<p>Let’s update our Makefile to add helpful annotations to <em>some</em> of our targets using comment blocks prefixed with <code>##</code></p>
<pre><code class="hljs language-Makefile"><span class="hljs-section">build: ## builds the application</span>
  @echo <span class="hljs-string">&quot;building...&quot;</span>

<span class="hljs-section">clean: ## gets you back to a clean working state</span>
  <span class="hljs-comment"># rm -rf build</span>

<span class="hljs-section">release: bump ## bump the VERSION file, git tags, and push to github</span>
  <span class="hljs-comment"># make push -e VERSION=$(shell cat VERSION)</span>
</code></pre>
<p>This annotation scheme works pretty well but doesn’t buy us anything on its own, to make this truly useful we need to parse the Makefile, look for lines prefixed with <code>##</code> and format them in a pretty way and write them to <code>stdout</code></p>
<h3 id="step-3-parse-annotations">Step 3: Parse Annotations</h3>
<p>Make includes a handy <a href="https://www.gnu.org/software/make/manual/html_node/Special-Variables.html#Special-Variables">list of special variables</a> that can be used for all sorts of handy things. In this case we can use the <code>MAKEFILE_LIST</code> variable along with <code>grep</code>, <code>sort</code> and <code>awk</code> to get a list of annotated targets and display them on <code>stdout</code> in a user-friendly way</p>
<pre><code class="hljs language-Makefile"><span class="hljs-section">help:</span>
  @grep -E &#x27;^[a-zA-Z_-]+:.*?<span class="hljs-comment">## .*$$&#x27; $(MAKEFILE_LIST) | sort | awk &#x27;BEGIN {FS = &quot;:.*?## &quot;}; {printf &quot;\033[36m%-30s\033[0m %s\n&quot;, $$1, $$2}&#x27;</span>
</code></pre>
<blockquote>
<p>Wondering what the <code>help</code> target is doing? See this <a href="https://explainshell.com/explain?cmd=grep+-E+%27%5E%5Ba-zA-Z_-%5D%2B%3A.*%3F%23%23+.*%24%24%27+%24%28MAKEFILE_LIST%29+%7C+sort+%7C+awk+%27BEGIN+%7BFS+%3D+%22%3A.*%3F%23%23+%22%7D%3B+%7Bprintf+%22%5C033%5B36m%25-30s%5C033%5B0m+%25s%5Cn%22%2C+%24%241%2C+%24%242%7D%27">explain shell</a>.</p>
</blockquote>
<p>With that in place our new developer would run <code>make</code> from the command-line and see</p>
<pre><code class="hljs language-shell">neophyte@newbie:~/code/project
<span class="hljs-meta">$ </span><span class="language-bash">make</span>
build           builds the application
clean           gets you back to a clean working state
release         bump the VERSION file, git tags, and push to github
</code></pre>
<p>Yay! This is a much nicer developer-experience than what we started with. To take it even further I might suggest annotating only a subset of tasks that are most commonly used.</p>
<h2 id="acknowledgements--links">Acknowledgements / Links</h2>
<p>There are a few sources that come up when you google for “self-documenting makefile” along with a few different ways of solving this problem. I drew inspiration for this post mostly from <a href="https://marmelab.com/blog/2016/02/29/auto-documented-makefile.html">this marmelab entry</a>, but felt like there were enough interesting points and general make tips added that it was worth another post.</p>
<p>Other links you may find useful:</p>
<ul>
<li><a href="https://gist.github.com/davemo/c0462e8196289e0fb0210ee63ff02962">Full Makefile as Gist</a></li>
<li><a href="https://gist.github.com/davemo/88de90577a57698dd72d722bcfc44964">VERSION bump script as Gist</a></li>
<li><a href="https://www.gnu.org/software/make/">GNU Make</a></li>
<li><a href="https://www.cmcrossroads.com/print/article/self-documenting-makefiles">Self Documenting Makefiles</a></li>
<li><a href="https://explainshell.com">Explain Shell</a></li>
</ul>
</article><div id="sidebar"><div class="profile_image"><img src="/img/davemo.headphones.png" alt="David A. Mosher"></div><p>David Mosher is a Canadian Software Developer, Designer, Musician, and Artist.</p><div class="icons"><a class="icon github" href="https://github.com/davemo" title="davemo on github"></a><a class="icon linkedin" href="https://linkedin.com/in/dmosher" title="dmosher on linkedin"></a><a class="icon twitter" href="https://twitter.com/dmosher" title="dmosher on twitter"></a><a class="icon youtube" href="https://youtube.com/davidmosher" title="davidmosher on youtube"></a></div></div><footer>&copy; 2007–2021 David A. Mosher</footer></div><script type="text/javascript" src="/js/app.js"></script></body></html>