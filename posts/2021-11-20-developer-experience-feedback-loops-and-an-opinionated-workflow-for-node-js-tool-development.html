<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" media="all" href="/css/app.css"><link rel="alternate" type="application/rss+xml" title="{ blog: david mosher }" href="/index.xml"><title>{ blog: david mosher } | Developer Experience, Feedback Loops, and an Enjoyable Workflow for Node.js Tool Development</title></head><body class="theme-tldr"><div id="wrap"><header><a href="/">{ blog: david mosher }</a><span class="description">thoughts on software, music, design, and meaning</span></header><nav><ul><li><a href="/">homepage</a></li><li><a href="/archive.html">archive</a></li></ul><div id="older-newer"><div class="older"><a href="/posts/2020-03-10-the-missing-fundamental.html">older</a></div></div></nav><article><h1><a href="/posts/2021-11-20-developer-experience-feedback-loops-and-an-opinionated-workflow-for-node-js-tool-development.html" title="Permanent link to ‚ÄòDeveloper Experience, Feedback Loops, and an Enjoyable Workflow for Node.js Tool Development‚Äô">Developer Experience, Feedback Loops, and an Enjoyable Workflow for Node.js Tool Development</a></h1><h6><time datetime="2021-11-20">November 20th, 2021</time></h6><aside class="tldr">
If you're experienced and prefer code to prose, you can explore the <a href="https://github.com/davemo/nodejs-tool-dev-template">code on github</a> or <code>npx degit davemo/nodejs-tool-dev-template</code>.
</aside>

<p>There‚Äôs been a lot of focus on the topic of DX or developer experience recently, which is <em>great</em> because it‚Äôs something that I‚Äôm passionate about improving on the teams I work with. So passionate, in fact, that I recently transitioned out of a customer-focused engineering role into one focused on developers, tooling, and infrastructure.</p>
<p>Now you might be asking yourself, ‚ÄòWhat does DX <em>actually</em> mean?‚Äô, and you would be justified in asking ‚Äì I‚Äôve heard varied interpretations of the term.</p>
<p><a href="https://twitter.com/jeanqasaur">Jean Yang</a> defines it this way in <a href="https://future.a16z.com/the-case-for-developer-experience/">The Case for Developer Experience</a>:</p>
<blockquote>
<p>What I mean by <strong>developer experience</strong> is the sum total of <strong>how</strong> developers interface with their <strong>tools</strong>, end-to-end, day-in and day-out.</p>
</blockquote>
<p>I think that a big part of the ‚Äúhow‚Äù there is the concept of <em>feedback loops</em>. Good developer tools provide affordances that reduce cognitive load, surface key information at the right time, but most importantly, good tools prioritize keeping feedback loops <em>fast</em> ‚Äì and nothing depletes my <a href="https://en.wikipedia.org/wiki/Ego_depletion">cognitive batteries</a> <em>faster</em> than slow, clunky tools.</p>
<h2 id="building-tools-with-nodejs">Building Tools with Node.js</h2>
<p>I first started working with Node around <a href="https://github.com/nodejs/node-v0.x-archive/blob/v0.4.0/ChangeLog">version 0.4</a> in 2011 and at the time I had absolutely no idea how anything worked. I came from a designer-first frontend background and my knowledge of JavaScript was limited to the context of the <a href="https://www.youtube.com/watch?v=Lsg84NtJbmI">browser</a>.</p>
<aside class="right">If you're new to systems programming altogether you might enjoy this <a href="https://gist.github.com/davemo/3c6042086deff4c2fd8a5f16751050d4" title="So, You want to be a Systems Engineer">gist I created</a> with some learning resources on the topic. Building tools with Node assumes at least some of this knowledge.
</aside>

<p>Jumping into Node was extremely disorienting for me, up was down and left was right, <code>window</code> was <code>global</code> and there was no <code>XHR</code> or <code>DOM</code>. Writing modules, packages, and command-line tools was all new to me, yet I was intrigued by the potential to leverage my knowledge of JavaScript within the world of tool building and systems programming.</p>
<p>Around this time I was working with <a href="https://twitter.com/searls">Searls</a>, who created <a href="https://www.youtube.com/embed/KERJkJNV5nI">Lineman</a> after I shared frustrations with most of the frontend tooling I was using.</p>
<p>This experience was transformative for me because up until that point the tools I was using were clunky, written in other languages I didn‚Äôt know as well, and incredibly slow. Justin‚Äôs focus on the DX of Lineman was immediately apparent and the fact that it was written in JavaScript (ok, and a <em>lot</em> of CoffeeScript) made it easy for me to contribute to. It was empowering to have someone listen to my frustrations and translate them into magic on the command-line!</p>
<p>Since then, I‚Äôve been able to work on some of my own tools, libraries, and plugins while picking up a few tips, tricks, and many opinions along the way. My hope is that sharing my experience will give you the <strong>starting place</strong> I wished for when learning to build tools in Node and lead you to a more enjoyable developer experience.</p>
<h2 id="ok-but-how-do-i-start">Ok, but how do I start?</h2>
<p>Great question! It‚Äôs the same one I had when I was interested in writing command-line tools with Node. The rest of this post will be a guided tutorial that I think will help you get started and answer the following questions:</p>
<ul>
<li>How can I <a href="#iterating-locally-using-npm-install-dir">iterate</a> on a node module locally without publishing to npm?</li>
<li>How can I test what I‚Äôm building in <a href="#testing-our-tool-in-another-project">another project</a>?</li>
<li>How can I <a href="#development-workflow-watch-build--debug">debug</a> the code while developing?</li>
<li>How should I <a href="#packaging-with-vercelncc-and-npm">package</a> things?</li>
</ul>
<aside>
Keep in mind, <b>I'm biased!</b> If you're experienced and have done this before there's a good chance my approach will probably differ from yours and that's ok. There are many tools and techniques I'm not familiar with -- please let me know on <a href="https://twitter.com/dmosher">twitter</a>. I'm always eager to learn.
</aside>

<h2 id="prerequisites">Prerequisites</h2>
<p> You‚Äôll need the following in order to follow along:</p>
<ul>
<li>an installation of <code>node &gt;= v16</code> and <code>npm &gt;= v8</code></li>
<li>a terminal app like <code>terminal.app</code> or <code>powershell</code></li>
<li>your favorite code editor</li>
<li><code>optional</code> a checkout of the <a href="https://github.com/davemo/blog-example-nodejs-workflows">full example</a> repo</li>
</ul>
<p>If you prefer to follow along step-by-step, let‚Äôs get started by running the following commands to create a workspace folder for the tutorial.</p>
<p>I like to use <code>~/code/node</code>, but you can use whatever you are most comfortable with.</p>
<pre><code class="hljs language-shell"><span class="hljs-meta">$ </span><span class="language-bash"><span class="hljs-comment"># create tutorial directory</span></span>
<span class="hljs-meta">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> -p ~/code/node</span>
<span class="hljs-meta">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> ~/code/node</span>
<span class="hljs-meta">
$ </span><span class="language-bash"><span class="hljs-comment"># create the my_project directory and initialize it with npm</span></span>
<span class="hljs-meta">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> my_project</span>
<span class="hljs-meta">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> my_project</span>
<span class="hljs-meta">$ </span><span class="language-bash">npm init -y</span>
<span class="hljs-meta">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> ..</span>
<span class="hljs-meta">
$ </span><span class="language-bash"><span class="hljs-comment"># create the my_tool directory and clone the workflow template</span></span>
<span class="hljs-meta">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> my_tool</span>
<span class="hljs-meta">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> my_tool</span>
<span class="hljs-meta">$ </span><span class="language-bash">npx degit davemo/nodejs-tool-dev-template</span>
<span class="hljs-meta">$ </span><span class="language-bash">npm i</span>
</code></pre>
<p>Using the <code>tree</code> <a href="https://formulae.brew.sh/formula/tree">command</a>, here‚Äôs what things should look like</p>
<pre><code class="hljs language-shell"><span class="hljs-meta">$ </span><span class="language-bash">tree -L 2 ~/code/node</span>

~/code/node
‚îú‚îÄ‚îÄ my_project
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ my_tool
    ‚îú‚îÄ‚îÄ dist
    ‚îú‚îÄ‚îÄ index.js          # executable entrypoint file
    ‚îú‚îÄ‚îÄ lib
    ‚îÇ   ‚îî‚îÄ‚îÄ tool.js       # module that logs to STDOUT
    ‚îú‚îÄ‚îÄ node_modules
    ‚îú‚îÄ‚îÄ package-lock.json
    ‚îú‚îÄ‚îÄ package.json
    ‚îî‚îÄ‚îÄ test

6 directories, 4 files
</code></pre>
<p>The <code>my_tool</code> directory comes with an entrypoint file <code>index.js</code> which will be our CLI tool. This entrypoint requires and executes <code>lib/tools.js</code> which logs a simple message to <code>STDOUT</code> and completes after a delay of 1 second. Here‚Äôs what those files look like</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// my_tool/index.js</span>
#!<span class="hljs-regexp">/usr/</span>bin/env node

<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./lib/tool.js&#x27;</span>)();
</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// my_tool/lib/tool.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">tool</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;‚è≥ CLI tool: working ...&#x27;</span>)
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;‚úÖ CLI tool: done!&#x27;</span>)
  }, <span class="hljs-number">1000</span>);
}
</code></pre>
<h2 id="iterating-locally-using-npm-install-dir">Iterating locally using <code>npm install &lt;dir&gt;</code></h2>
<p>Often you will want to test a node module in another project locally without having to publish it. There are a few ways to do this but we want to optimize for the best developer experience in our workflow, so I‚Äôm going to focus on using <code>npm install &lt;dir&gt;</code>.</p>
<aside>
We could also achieve this using <a href="https://docs.npmjs.com/cli/v8/commands/npm-link">npm link</a>, but that involves extra steps and requires us to remember that we've linked things and it ends up just being a lot more to manage. Another alternative that I've seen is <a href="https://pnpm.io/cli/link">pnpm link</a>, but that is beyond the scope of this blog post.
</aside>

<h3 id="install-my_tool-from-within-my_project">Install <code>my_tool</code> from within <code>my_project</code></h3>
<pre><code class="hljs language-shell"><span class="hljs-meta">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> my_project</span>
<span class="hljs-meta">$ </span><span class="language-bash">npm install ../my_tool</span>

added 1 package, and audited 3 packages in 634ms
</code></pre>
<p>Installing a package this way causes <em>three</em> side-effects that we should know about</p>
<pre><code class="hljs language-shell"><span class="hljs-meta">$ </span><span class="language-bash"><span class="hljs-comment"># a symbolic link for my_tool is created in node_modules</span></span>
<span class="hljs-meta">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -la my_project/node_modules</span>
my_tool -&gt; ../../my_tool
<span class="hljs-meta">
$ </span><span class="language-bash"><span class="hljs-comment"># a symbolic link for the executable is created in node_modules/.bin</span></span>
<span class="hljs-meta">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -la my_project/node_modules/.bin</span>
my_tool -&gt; ../my_tool/dist/index.js
<span class="hljs-meta">
$ </span><span class="language-bash"><span class="hljs-comment"># my_tool is added to dependencies mapped to a relative file path</span></span>
<span class="hljs-meta">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> package.json | grep -A2 dependencies</span>
&quot;dependencies&quot;: {
  &quot;my_tool&quot;: &quot;file:../my_tool&quot;
}
</code></pre>
<blockquote>
<p>The addition of the relative <code>file:</code> path in <code>dependencies</code> is nice because it serves as a physical reminder that we are in development mode; something we don‚Äôt get using <code>npm link</code>.</p>
</blockquote>
<p>Now that we‚Äôve got things installed, we‚Äôre ready to start iterating on <code>my_tool</code> and testing how it works inside of <code>my_project</code>.</p>
<h2 id="testing-our-tool-in-another-project">Testing our tool in another project</h2>
<p>To work with <code>my_tool</code> inside of <code>my_project</code> we‚Äôre going to use <a href="https://docs.npmjs.com/cli/v8/using-npm/scripts">npm scripts</a> inside <code>my_project/package.json</code>. Let‚Äôs add a script <code>log_a_message</code> that invokes <code>my_tool</code>:</p>
<pre><code class="hljs language-json"><span class="hljs-comment">// my_project/package.json</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my_project&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;index.js&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;log_a_message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my_tool&quot;</span> <span class="hljs-comment">// add this script</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;license&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ISC&quot;</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>We can now execute <code>npm run log_a_message</code> to invoke <code>my_tool</code>. If everything is linked correctly you should see something like this</p>
<pre><code class="hljs language-shell"><span class="hljs-meta">$ </span><span class="language-bash">npm run log_a_message</span>
<span class="hljs-meta">
&gt; </span><span class="language-bash">my_project@1.0.0 log_a_message</span>
<span class="hljs-meta">&gt; </span><span class="language-bash">my_tool</span>

‚è≥ CLI tool: working ...
‚úÖ CLI tool: done!
</code></pre>
<h3 id="what-happens-when-we-call-npm-run-log_a_message">What happens when we call <code>npm run log_a_message</code>?</h3>
<p>To better understand what‚Äôs going on, let‚Äôs take a look at the <code>name</code> and <code>bin</code> keys within the scaffolded <code>package.json</code> that came with the workflow template</p>
<pre><code class="hljs language-json"><span class="hljs-comment">// my_tool/package.json</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my_tool&quot;</span><span class="hljs-punctuation">,</span>

  <span class="hljs-comment">// explicit mapping syntax</span>
  <span class="hljs-attr">&quot;bin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;my_tool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dist/index.js&quot;</span> <span class="hljs-comment">// bin.my_tool invokes dist/index.js</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>

  <span class="hljs-comment">// implicit mapping syntax</span>
  <span class="hljs-attr">&quot;bin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dist/index.js&quot;</span> <span class="hljs-comment">// package.name invokes dist/index.js</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<blockquote>
<p>In our case, because the name of the package and the command are the same, we <em>could</em> simplify using the <code>implicit</code> syntax, but I generally prefer to use the <code>explicit</code> syntax just to make it clear to future readers.</p>
</blockquote>
<p>The <code>bin</code> key in <code>my_tool/package.json</code> is a mapping of the command name (<code>my_tool</code>) to the local file name (<code>dist/index.js</code>) that will be executed.</p>
<p>With that in mind, this is roughly what happens when we run <code>npm run log_a_message</code>:</p>
<ul>
<li>npm looks for <code>scripts.log_a_message</code> in <code>my_project/package.json</code></li>
<li>npm appends <code>my_project/node_modules/.bin</code> to the shell‚Äôs pre-existing <code>PATH</code></li>
<li>npm resolves <code>my_tool</code> to <code>my_project/node_modules/.bin/my_tool</code> which is a symlink to <code>my_tool/dist/index.js</code> because of the <code>bin</code> mapping.</li>
<li><code>my_tool/dist/index.js</code> contains a <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">unix shebang</a> <code>#!/usr/bin/env node</code></li>
<li>the script is effectively executed with <code>node my_tool/dist/index.js</code></li>
</ul>
<aside><strong>Phew!</strong> That's a lot of moving parts behind the scenes, but I often find it helpful to understand the layers beneath the abstractions that I'm working with.</aside>

<h2 id="development-workflow-watch-build--debug">Development workflow: <code>(watch, build) + (debug)</code></h2>
<p>With <code>my_tool</code>installed within <code>my_project</code>, the next thing we might want to do is debug our tooling code as we iterate while developing. There are a few included npm scripts in the workflow template that we‚Äôll find within <code>my_tool/package.json</code>:</p>
<pre><code class="hljs language-json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
  <span class="hljs-comment">// watch: runs the build, compiling on every change</span>
  <span class="hljs-attr">&quot;watch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;npm run build -- -w&quot;</span><span class="hljs-punctuation">,</span>

  <span class="hljs-comment">// build: a one time compile using @vercel/ncc</span>
  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ncc build index.js -o dist --source-map&quot;</span><span class="hljs-punctuation">,</span>

  <span class="hljs-comment">// debug: open ndb to debug our compiled tool</span>
  <span class="hljs-attr">&quot;debug&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ndb dist/index.js&quot;</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 id="watch--build-with-vercelncc">Watch + Build with <code>@vercel/ncc</code></h3>
<p>The <code>watch</code> target here invokes <code>build</code> and passes along the <code>-w</code> parameter which tells <code>ncc</code> that it should watch for file changes and recompile every time a change is detected.</p>
<p>The <code>build</code> target invokes <code>ncc</code>, which traverses the dependency graph starting at our <code>index.js</code> entrypoint, and compiles everything it finds (including dynamically imported things) into a single file with all dependencies inlined, kind of like <code>gcc</code>.</p>
<p>To kick things off, run <code>npm run watch</code> from within <code>my_tool</code>:</p>
<pre><code class="hljs language-shell"><span class="hljs-meta">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> my_tool</span>
<span class="hljs-meta">$ </span><span class="language-bash">npm run watch</span>
<span class="hljs-meta">
&gt; </span><span class="language-bash">my_tool@1.0.0 watch</span>
<span class="hljs-meta">&gt; </span><span class="language-bash">npm run build -- -w</span>
<span class="hljs-meta">
&gt; </span><span class="language-bash">my_tool@1.0.0 build</span>
<span class="hljs-meta">&gt; </span><span class="language-bash">ncc build index.js -o dist --source-map <span class="hljs-string">&quot;-w&quot;</span></span>

ncc: Version 0.31.1
ncc: Compiling file index.js into CJS
File change, rebuilding...
 2kB  dist/index.js
 2kB  dist/index.js.map
40kB  dist/sourcemap-register.js
42kB  [113ms] - ncc 0.31.1
Watching for changes...
</code></pre>
<p>I like starting with this ‚Äúwatch-build‚Äù workflow when developing for a few reasons:</p>
<ul>
<li><p>‚úÖ It compiles on every file change and compilation is effectively the first unit test; this gains us confidence that we aren‚Äôt introducing simple bugs as we develop.</p>
</li>
<li><p>üì¶ It sets us up to be ready to publish our module to npm as soon as we are done developing; the <code>dist</code> folder is the only thing we need to upload to npm.</p>
</li>
<li><p>‚è≠ <code>ncc</code> generates sourcemaps, so we get the same DX benefits of debugging against <code>my_tool/index.js</code> in concert with the compilation benefits above.</p>
</li>
</ul>
<h3 id="debugging-with-ndb">Debugging with <code>ndb</code></h3>
<p>The <code>debug</code> target spins up <code>ndb</code> pointing at our single compiled file in <code>dist/index.js</code>. The feedback loop when developing and debugging is nearly instant, and <code>ndb</code> includes some really nice DX features which we‚Äôll look at shortly.</p>
<p>First, let‚Äôs add a <code>debugger</code> statement within <code>my_tool/lib/tool.js</code> knowing that it will be compiled into <code>dist/index.js</code> automatically by our Watch + Build process.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// my_tool/lib/tool.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">tool</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;‚è≥ CLI tool: working ...&#x27;</span>)
  <span class="hljs-keyword">debugger</span>; <span class="hljs-comment">// add a debugger statement here</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;another one&#x27;</span>);
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;‚úÖ CLI tool: done!&#x27;</span>)
  }, <span class="hljs-number">1000</span>);
}
</code></pre>
<p>Then, in another terminal window let‚Äôs spin up <code>ndb</code> using <code>npm run debug</code>:</p>
<pre><code class="hljs language-shell"><span class="hljs-meta">$ </span><span class="language-bash">npm run debug</span>
<span class="hljs-meta">
&gt; </span><span class="language-bash">my_tool@1.0.0 debug</span>
<span class="hljs-meta">&gt; </span><span class="language-bash">ndb dist/index.js</span>

Downloading Chromium r624492...
Chromium downloaded to /Users/davidmosher/code/node/my_tool/node_modules/carlo/lib/.local-data/mac-624492
‚è≥ CLI tool: working ...
</code></pre>
<blockquote>
<p>The first time you run the <code>debug</code> target <code>ndb</code> will download Chromium.</p>
</blockquote>
<p>With this process launched you should see a Chromium window pop up:</p>
<img class="screenshot" src="/img/nodejs-tooling-development-workflow/ndb-example.png" alt="The Chromium window launched by ndb" />

<p>This is where we can see some of the <code>ndb</code> DX specifics I mentioned earlier that make this workflow so nice.</p>
<ul>
<li><p>üìÉ Notice the <code>NPM Scripts</code> tab? This allows you to repeatedly invoke any npm script right from the GUI. This is really handy for making changes and then testing them immediately.</p>
</li>
<li><p>üîÅ <code>ndb</code> stays launched and available for you to re-run any of those npm scripts; this is much nicer than <code>node --inspect-brk</code> which exits after the current debug stack is completed.</p>
</li>
<li><p>‚è≠ We can see those sourcemaps I mentioned before at work here, <code>lib/tool.js</code> shows up in the source pane even though we‚Äôre debugging <code>dist/index.js</code>.</p>
</li>
<li><p>üêõ Finally, all of your other Chrome DevTools muscle memory applies just the same here as it does when debugging client-side JavaScript! The step-debugger, sources panel, and snippets can all come in handy working here in a node-based JS context.</p>
</li>
</ul>
<h2 id="packaging-with-vercelncc-and-npm">Packaging with <code>@vercel/ncc</code> and <code>npm</code></h2>
<p>When you‚Äôve finished creating your command-line masterpiece the next thing you may want to do is publish it to the npm registry so that others can <code>npm install</code> it. Thankfully, this step is easy because we already configured <code>ncc</code> to build for production in the <code>dist</code> folder via our <code>build</code> npm script.</p>
<p>The last thing to consider is how to minimize the size of our package when a user installs it with <code>npm install</code>, and this has already been done for us in the <code>files</code> key within <code>my_tool/package.json</code> key:</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my_tool&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a template for developing node.js command-line tools&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;index.js&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;bin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;my_tool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dist/index.js&quot;</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;files&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-string">&quot;dist&quot;</span>
  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-comment">// ...</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<blockquote>
<p>NPM has some <a href="https://docs.npmjs.com/cli/v8/configuring-npm/package-json#files">documentation</a> on a few other <code>files</code> details that you may find helpful.</p>
</blockquote>
<p>Limiting <code>files</code> to just the <code>dist</code> directory ensures that we keep our package as small as possible, which is already taken care of thanks to <code>ncc</code> producing a single file. If you want a double check to see <em>exactly</em> which files npm would add to the package, you can run <code>npx npm-packlist</code>:</p>
<pre><code class="hljs language-shell"><span class="hljs-meta">$ </span><span class="language-bash">npx npm-packlist</span>

index.js
package.json
dist/index.js
dist/index.js.map
dist/sourcemap-register.js
</code></pre>
<p>Our last step before publishing will be to remove the <code>private: true</code> flag from <code>package.json</code>, which I added so nobody accidentally published the workflow template. Once that‚Äôs done, then you can simply <code>npm publish</code> and your minimal package will be uploaded to the npm registry.</p>
<aside>If you don't provide a tag when you publish, npm will automatically assign your published package to the <code>latest</code> specifier, which would allow you to install it using <br><code>npm install my_tool@latest</code>.</aside>

<h2 id="wrapping-up">Wrapping up</h2>
<p>This concludes my tutorial on an enjoyable workflow for Node.js tool development. I hope you found this useful and that you find the experience of developing tools in this way enjoyable and the feedback loop fast and efficient.</p>
<p>If you have questions or wish to provide feedback, please reach out to me on <a href="https://twitter.com/dmosher">twitter</a>. I would love to hear from you!</p>
<p>Happy tool-making. üíö</p>
</article><div id="sidebar"><div class="profile_image"><img src="/img/davemo.headphones.png" alt="David A. Mosher"></div><p>David Mosher is a Canadian Software Developer, Designer, Musician, and Artist.</p><div class="icons"><a class="icon github" href="https://github.com/davemo" title="davemo on github"></a><a class="icon linkedin" href="https://linkedin.com/in/dmosher" title="dmosher on linkedin"></a><a class="icon twitter" href="https://twitter.com/dmosher" title="dmosher on twitter"></a><a class="icon youtube" href="https://youtube.com/davidmosher" title="davidmosher on youtube"></a></div></div><footer>&copy; 2007‚Äì2021 David A. Mosher</footer></div><script type="text/javascript" src="/js/app.js"></script></body></html>