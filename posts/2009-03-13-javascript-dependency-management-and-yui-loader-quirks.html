<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" media="all" href="/css/app.css"><link rel="alternate" type="application/rss+xml" title="{ blog: david mosher }" href="/index.xml"><title>{ blog: david mosher } | javascript dependency management and yui loader quirks</title></head><body><div id="wrap"><header class="root"><h1><a href="/">{ blog: david mosher }</a></h1><h2>personal opinions from a software developer living in ottawa, canada</h2></header><aside id="sidebar"><section id="profile"><a href="https://github.com/davemo" title="David Mosher's Github"><img class="profile_image" src="/img/davemo.headphones.png" alt="David Mosher"></a><p>Programmer, Designer, UX&apos;er, Hacker, Musician, Artist ... wearer of many hats ðŸ¤“</p><div class="icons"><a class="icon github" href="https://github.com/davemo" title="davemo on github"></a><a class="icon linkedin" href="https://linkedin.com/in/dmosher" title="dmosher on linkedin"></a><a class="icon twitter" href="https://twitter.com/dmosher" title="dmosher on twitter"></a><a class="icon youtube" href="https://youtube.com/davidmosher" title="davidmosher on youtube"></a></div></section><nav><a href="/">homepage</a><a href="/archive.html">blog archives</a></nav></aside><article class="post clearfix"><header><section id="navigation"><time id="pub-date" datetime=""><a href="/posts/2009-03-13-javascript-dependency-management-and-yui-loader-quirks.html">March 13th, 2009</a></time><div class="older-newer"><div class="newer"><a href="/posts/2009-03-24-yui-uploader-and-ie7-flash-bugs.html">&#8672;&nbsp;newer</a></div><div class="older"><a href="/posts/2008-12-17-application-usage-trends.html">older&nbsp;&#8674;</a></div></div></section><h1 class="post-title"><a href="/posts/2009-03-13-javascript-dependency-management-and-yui-loader-quirks.html">javascript dependency management and yui loader quirks</a></h1></header><section class="body"><div class="inner"><p><a href="https://bzabos.wordpress.com/">Brett</a> and I recently began refactoring a
significant amount of the JavaScript that is currently in
<a href="https://www.myfrontsteps.com">MyFrontSteps</a> and
<a href="https://www.myfrontsteps.com/myfrontsteps/home/">Homebook</a>. One of the areas we
identified as needing improvement was controlling when scripts get loaded in the
page; it&#39;s a challenging subject especially when utilizing Django templates
which can extend and include bits of HTML that are both static and dynamic.
We&#39;re not finished the refactoring quite yet but I thought it would be valuable
to blog about the lessons we&#39;ve learned early on about how to manage JavaScript
loading without having script tags all over the place.</p>
<h3 id="manual-dependency-management-is-hard">Manual Dependency Management is Hard</h3>
<p>Not too long ago, Yahoo put out a list of
<a href="https://developer.yahoo.com/performance/rules.html">guidelines</a> that web
developers can use to enhance the performance of their websites. I won&#39;t get
into it in this post but there is a Firefox plugin called
<a href="https://developer.yahoo.com/yslow/">YSlow</a> available that can automate some of
the performance checking. The recommendation I&#39;m going to focus on here is the
one regarding moving scripts as close to the bottom of the page as possible.
I&#39;ll just quote the <a href="https://developer.yahoo.com/performance/rules.html">Yahoo
doc</a> as they explain it very
clearly:</p>
<blockquote>
<p>The problem caused by scripts is that they block parallel downloads. The
<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.1.4">HTTP/1.1
specification</a>
suggests that browsers download no more than two components in parallel per
hostname. If you serve your images from multiple hostnames, you can get more
than two downloads to occur in parallel. While a script is downloading,
however, the browser won&#39;t start any other downloads, even on different
hostnames. In some situations it&#39;s not easy to move scripts to the bottom. If,
for example, the script uses <code>document.write</code>to insert part of the page&#39;s
content, it can&#39;t be moved lower in the page. There might also be scoping
issues. In many cases, there are ways to workaround these situations.</p>
</blockquote>
<p>In the case of the code we&#39;re using on MyFrontSteps we had all kinds of Django
templates with includes and templatetags that include other little bits of
dynamic JavaScript that was adding markup to the DOM and manipulating DOM
content. Some of this code would appear prior to certain dependent scripts being
loaded which created a real nightmare for us as we had to manually track down
the position of the dependent scripts in the page that was fed to the browser
after a variable number of layers of templates and includes. We decided to
research a better way to manage all these scripts and since we had been using
the YUI library for many other parts of the website we settled on the <a href="https://developer.yahoo.com/yui/yuiloader/">YUI
loader</a>.</p>
<h3 id="yui-loader-makes-dependency-management-easy">YUI Loader Makes Dependency Management Easy</h3>
<blockquote>
<p>The YUI Loader Utility is a client-side JavaScript component that allows you
to load specific YUI components and their dependencies into your page via
script. YUI Loader can operate as a holistic solution by loading all of your
necessary YUI components, or it can be used to add one or more components to a
page on which some YUI content already exists.</p>
</blockquote>
<p>The great thing about the YUI Loader is that you can use it to manage dependency
sorting for all of the YUI components you use on a page but the <em>killer</em> feature
imho is the fact that it allows you to create custom modules to load your own JS
and CSS libraries. The basic pattern we&#39;re using in our root level Django
template is as follows:</p>
<ol>
<li>Load all CSS Files at the top of the template</li>
<li>Place all YUI Loader and other statically included scripts at the bottom of
the page prior to the closing BODY tag</li>
<li>Define the YUI Loader instance</li>
<li>Define custom modules for the YUI loader</li>
<li>Provide a Django template block to allow manipulation of the onSuccess
callback</li>
<li>Call the YUI Loaders .insert() method to trigger insertion of all dependency
sorted scripts into the DOM</li>
</ol>
<p>The advantage to using the loader in conjunction with our root Django template
is clear; all of our scripts are loaded at the bottom of the page and CSS is
loaded at the top. When a user requests the pages they will start receiving the
content from the server immediately and not have to wait for scripts to process
as the loader dynamically inserts them into the HEAD element after the page
content has been rendered. Another trick we&#39;re using to control when scripts get
executed is by manipulating how the onSuccess callback of the loader works.
Here&#39;s the code:</p>
<blockquote>
<pre><code><span class="hljs-comment">// Instantiate and configure YUI Loader:</span>
MFSLoader = <span class="hljs-keyword">new</span> YAHOO.util.YUILoader({
    base: <span class="hljs-string">""</span>,
    <span class="hljs-keyword">require</span>: [<span class="hljs-string">"base"</span>,<span class="hljs-string">"reset-fonts-grids"</span>,<span class="hljs-string">"MFS"</span>],
    loadOptional: <span class="hljs-keyword">false</span>,
    combine: <span class="hljs-keyword">true</span>,
    filter: <span class="hljs-string">"MIN"</span>,
    allowRollup: <span class="hljs-keyword">true</span>,
    onSuccess: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">while</span>( MFSLoader.onReady.length )  {
            MFSLoader.onReady.shift()();
        }
    }
});

<span class="hljs-comment">// Define a list of executables that we</span>
<span class="hljs-comment">// can add to prior to page load completion</span>
MFSLoader.onReady = [];

<span class="hljs-comment">// Custom Modules for Loader</span>
MFSLoader.addModule({
    name: <span class="hljs-string">'MFS'</span>, type: <span class="hljs-string">'js'</span>, varName: <span class="hljs-string">'MFS'</span>,
    path: <span class="hljs-string">'{% vurl "/static/script/MFS.js" %}'</span>,
    requires: [<span class="hljs-string">'jQuery'</span>, <span class="hljs-string">'jQueryUI'</span>]
});

{<span class="hljs-comment"># Override this block if you need script at the global level. #}</span>
{% block <span class="hljs-keyword">global</span>.script %}{% endblock %}
<span class="hljs-comment">// Trigger insertion of all dependency sorted scripts into the DOM</span>
MFSLoader.insert();
</code></pre></blockquote>
<p>As you can see we have a few of the custom modules defined here, which include a
&#39;requires&#39; attribute in the configuration object. This lets the YUI Loader know
that these files require the other modules to be loaded. The Loader then
determines sort order for inclusion based on all required modules and goes to
work inserting the scripts for you.</p>
<h3 id="tying-it-all-together">Tying it all Together</h3>
<p>The key to making this work in the varying levels of Django templates is to
manipulate the onSuccess callback. When the YUI Loader finishes loading all the
dependency sorted scripts it will execute this callback and allow you to then
execute any additional code that depends on the dynamically inserted scripts. We
have a number of namespaced JS objects for MyFrontSteps (MFS.js, MFS.DataGrid.js
etc..) and when we need to call functions defined in these objects we do so by
extending the global.script block in our child template and pushing a new
anonymous function onto the MFSLoader.onReady list we defined in the root
template. Here&#39;s a simple example:</p>
<blockquote>
<pre><code>{<span class="hljs-comment"># A CHILD TEMPLATE #}</span>
{% block <span class="hljs-keyword">global</span>.script %}
    <span class="hljs-comment">#include the parent templates global.script contents</span>
    {{ block.super }}

    <span class="hljs-comment">// Load our required features</span>
    MFSLoader.<span class="hljs-keyword">require</span>( <span class="hljs-string">'MFS.DataGrid'</span>, <span class="hljs-string">'uploader'</span>, <span class="hljs-string">'MFS.Uploader'</span> );
    <span class="hljs-comment">// Push an anonymous function onto the list</span>
    <span class="hljs-comment">// to get executed when all required scripts have been loaded</span>
    MFSLoader.onReady.push( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>  </span>{
        MFS.DataGrid.initPhotosGrid();
    });
{% endblock %}
</code></pre></blockquote>
<p>Once the page is rendered and the YUI Loader has finished parsing the loaded
scripts the code we have in the onSuccess callback pops all the anonymous
functions off the list which causes them to be executed.</p>
<blockquote>
<pre><code>{<span class="hljs-comment"># THE ONSUCCESS CALLBACK #}</span>
onSuccess: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">while</span>( MFSLoader.onReady.length )  {
        MFSLoader.onReady.shift()();
    }
}
</code></pre></blockquote>
<p>We still have a number of files to refactor, but the performance benefits we&#39;ve
seen so far using this approach have really made us confident that this is the
way to go. Using a dependency manager that works for custom JS / CSS libraries
is just so much more liberating than having to manually keep track of where
scripts are getting executed. Because we&#39;re also migrating all of our code to
external library files it makes things that much easier to debug in Firebug as
well. :)</p>
</div></section></article><footer class="root">&copy; 2021 - David A. Mosher</footer></div><script type="text/javascript" src="/js/app.js"></script></body></html>