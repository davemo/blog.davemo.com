<!DOCTYPE html><html><head><link rel="stylesheet" type="text/css" media="all" href="/css/app.css"><link rel="alternate" type="application/rss+xml" title="david mosher" href="/index.xml"><title>david mosher | the missing fundamental</title></head><body><div id="wrap"><header class="root"><h1><a href="/">david mosher</a></h1><h2>personal and semi-professional opinions of a web designer and developer living in ottawa, canada</h2></header><aside id="sidebar"><section id="profile"><h1><a href="http://github.com/davemo" title="David Mosher's Github"><img class="profile_image" src="/img/davatar.jpg" alt="David Mosher"></a></h1><p>Programmer, Designer, UX&apos;er, Hacker, Musician, ... wearer of many hats</p><a href="http://github.com/davemo">@davemo on github</a></section><nav><a href="/">home&nbsp;</a><a href="/archive.html">archives</a></nav></aside><article class="post clearfix"><header><section id="navigation"><time id="pub-date" datetime=""><a href="/posts/2020-03-10-the-missing-fundamental.html">March 10th, 2020</a></time><div class="older-newer"><div class="older"><a href="/posts/2019-08-27-css-the-visual-state-machine.html">older&nbsp;&#8674;</a></div></div></section><h1 class="post-title"><a href="/posts/2020-03-10-the-missing-fundamental.html">the missing fundamental</a></h1></header><section class="body"><div class="inner"><p>Music composition and production is a large part of my life outside of software development, so much so that I often find myself thinking of ways to draw parallels between the two. One such parallel that has stuck with me over the past 6 months or so is the concept of <a href="https://en.wikipedia.org/wiki/Missing_fundamental">the missing fundamental</a>.</p>
<blockquote>
<p>A harmonic sound is said to have a <strong>missing fundamental</strong>, <strong>suppressed fundamental</strong>, or <strong>phantom fundamental</strong> when its overtones suggest a fundamental frequency but the sound lacks a component at the fundamental frequency itself.</p>
</blockquote>
<p>When I first learned about this concept, I couldn&#39;t help but think of how it applied to the work we do as software engineers. In the same way that skilled audio engineers can leverage the concept of the missing fundamental to improve the characteristics of sound, skilled software engineers can use a similar set of skills to improve the performance of applications.</p>
<blockquote>
<p>This very concept of &quot;missing fundamental&quot; being reproduced based on the overtones in the tone has been used to create the illusion of bass in sound systems that are not capable of such bass. In mid-1999, Meir Shashoua of Tel Aviv, co-founder of Waves Audio, patented an algorithm to create the sense of the missing fundamental by synthesizing higher harmonics. Waves Audio released the MaxxBass plug-in to allow computer users to apply the synthesized harmonics to their audio files.</p>
</blockquote>
<h1 id="the-fundamentals-of-software-performance">The Fundamentals of Software Performance</h1>
<p><a href="https://blog.testdouble.com/authors/ali-ibrahim/">Ali</a> and I were recently tasked with improving the performance of a legacy codebase that was deployed on Heroku using Node.js, MongoDB, and Angular 1. One of our first steps in evaluating the performance of code is to do an audit of dependencies and configuration; this is a great starting point because it can often lead to simple fixes for performance issues, like updating a database ORM adapter that can query things more efficiently.</p>
<p>In this case an audit of dependencies didn&#39;t yield much and we had to dive further into configuration on Heroku to really make sense of the performance challenge. Significant discovery number one was that the application was configured using Performance L <a href="https://www.heroku.com/dynos">dynos</a> on Heroku (the most expensive <em>and</em> highest tier available). This seemed strange since it did not appear commensurate with the surface area of the application; its purpose was to sync data using Heroku scheduler to pull from SalesForce into MongoDB.</p>
<p>One of our first steps was to reduce the dyno size and monitor logs to see if the Performance L size was warranted.</p>
<h2 id="fundamental-1-investigate">Fundamental #1: Investigate</h2>
<p>Heroku makes it pretty easy to peek at logs for your app, which is what we started with: <code>heroku logs --tail -a td-client-slow-app</code>. This yielded the following trace:</p>
<pre><code class="lang-shell">app[web<span class="hljs-number">.1</span>]:
app[web<span class="hljs-number">.1</span>]: &lt;--- Last few GCs ---&gt;
app[web<span class="hljs-number">.1</span>]:
app[web<span class="hljs-number">.1</span>]: &lt;--- JS stacktrace ---&gt;
app[web<span class="hljs-number">.1</span>]:
app[web<span class="hljs-number">.1</span>]: ==== JS stack trace ==========
app[web<span class="hljs-number">.1</span>]:
app[web<span class="hljs-number">.1</span>]: <span class="hljs-number">0</span>: ExitFrame [pc: <span class="hljs-number">0x1374fd9</span>]
app[web<span class="hljs-number">.1</span>]: Security context: <span class="hljs-number">0x01f9540008a1</span> &lt;JSObject&gt;
app[web<span class="hljs-number">.1</span>]: <span class="hljs-number">1</span>: getOwnPropertyNames [<span class="hljs-number">0x1f954001251</span>](truncated...)
app[web<span class="hljs-number">.1</span>]: <span class="hljs-number">2</span>: getOwnPropertyDescriptors [<span class="hljs-number">0x3dffde9f7229</span>]
[/app/node_modules/mongoose/lib/helpers/document/compile.js:<span class="hljs-number">159</span>]
app[web<span class="hljs-number">.1</span>]:
app[web<span class="hljs-number">.1</span>]: FATAL ERROR: Ineffective mark-compacts
app[web<span class="hljs-number">.1</span>]: near heap limit Allocation failed -
app[web<span class="hljs-number">.1</span>]: JavaScript heap <span class="hljs-keyword">out</span> of memory
</code></pre>
<p>(Note: The <a href="https://devcenter.heroku.com/articles/slug-compiler">slug</a> for this application was ~74mb, which didn&#39;t seem overly large to warrant running out of memory on the lowest tier dyno Heroku provides. That dyno allocates up to 512mb of RAM, so we dug into the code path that led to the above stacktrace to gain some more information.)</p>
<h2 id="fundamental-2-profile">Fundamental #2: Profile</h2>
<p>Node.js has some pretty decent profiling tools for engineers who want to dive into performance profiling. TD-resident DevOps pro <a href="https://blog.testdouble.com/authors/micah-adams/">Micah</a> showed me that you can add some flags to the <code>node</code> process on startup to influence how V8 manages garbage collection. This is useful if you aren&#39;t getting consistency in your crashes and want to place constraints on the application runtime in order to suss out the source of the memory leak.</p>
<p><code>node --optimize_for_size --max_old_space_size=460 app.js</code></p>
<p>Artifically lowering the max heap size below what Heroku provisions for Standard dynos yielded the source of the leak was a method called <code>getUsers</code> which was responsible for querying a list of users and their permissions from MongoDB. Here&#39;s a sample of what that code looked like as we first found it:</p>
<pre><code class="lang-javascript">getUsers: function(req, res) {
  User.find({}, function(err, users) {
    var allUsers = users<span class="hljs-comment">;</span>
    var adminUsers = []<span class="hljs-comment">;</span>
    var corpUsers = []<span class="hljs-comment">;</span>
    var techUsers = []<span class="hljs-comment">;</span>
    var formalUsers = []<span class="hljs-comment">;</span>
    var searchUsers = []<span class="hljs-comment">;</span>
    users.forEach(function(<span class="hljs-literal">user</span>) {
      if(<span class="hljs-literal">user</span>.permissions.<span class="hljs-literal">admin</span> &amp;&amp;
         (<span class="hljs-literal">user</span>.permissions.<span class="hljs-literal">admin</span>.corpUsers ||
          <span class="hljs-literal">user</span>.permissions.<span class="hljs-literal">admin</span>.techUsers ||
          <span class="hljs-literal">user</span>.permissions.<span class="hljs-literal">admin</span>.formalUsers ||
          <span class="hljs-literal">user</span>.permissions.<span class="hljs-literal">admin</span>.searchUsers ||
          <span class="hljs-literal">user</span>.permissions.<span class="hljs-literal">admin</span>.superAdmin)) {
        adminUsers.push(<span class="hljs-literal">user</span>)<span class="hljs-comment">;</span>
      }
      if(<span class="hljs-literal">user</span>.permissions.general.corpUsers) {
        corpUsers.push(<span class="hljs-literal">user</span>)<span class="hljs-comment">;</span>
      }
      if(<span class="hljs-literal">user</span>.permissions.general.formalUsers) {
        formalUsers.push(<span class="hljs-literal">user</span>)<span class="hljs-comment">;</span>
      }
      if(<span class="hljs-literal">user</span>.permissions.general.search) {
        searchUsers.push(<span class="hljs-literal">user</span>)<span class="hljs-comment">;</span>
      }
      // this continued <span class="hljs-literal">on</span> for another <span class="hljs-number">40</span> lines or so...
    })
  })
}
</code></pre>
<p>Node.js has <a href="https://nodejs.org/api/perf_hooks.html">performance tooling</a> built-in that allows you to gain insight around memory and CPU usage, which is what we used next:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> { PerformanceObserver, performance } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'perf_hooks'</span>)
<span class="hljs-keyword">const</span> o = <span class="hljs-keyword">new</span> PerformanceObserver(<span class="hljs-function">(<span class="hljs-params">items</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(items.getEntries()[<span class="hljs-number">0</span>]);
  performance.clearMarks();
})
o.observe({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">'measure'</span>]})
</code></pre>
<pre><code class="lang-javascript"><span class="hljs-comment">// to get the approx mem usage you can add this log line:</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`
  The script uses ~
  <span class="hljs-subst">${process.memoryUsage().heapUsed <span class="hljs-regexp">/ 1024 /</span> <span class="hljs-number">1024</span>}</span>
  MB
`</span>)
</code></pre>
<pre><code class="lang-shell"><span class="hljs-comment"># Output</span>
PerformanceEntry {
  name: <span class="hljs-string">'getUsers to res.status(200)'</span>,
  entryType: <span class="hljs-string">'measure'</span>,
  startTime: 5486.524808,
  duration: 6559.275542
}
The<span class="hljs-built_in"> script </span>uses ~ 456.143798828125 MB
</code></pre>
<p>Looking at this code I couldn&#39;t help but wonder if there was a more efficient way to query and aggregate this information.</p>
<h2 id="fundamental-3-identify-the-missing-fundamental">Fundamental #3: Identify the <em>Missing</em> Fundamental</h2>
<p>Returning to the idea of the missing fundamental, as audio engineers must ask themselves &quot;what can I change about the frequencies in this mix in order to bring things into harmony?&quot; the relevant question for software engineers is very similar: &quot;what does this system need in order to bring harmony to its operation?&quot;. In our case it was also helpful to consider that question in a historical context as &quot;what fundamental were the original developers missing when they built this?&quot;</p>
<p>In both cases, the answer for this application was <strong>how to query things more efficiently</strong>!</p>
<p>The <code>getUsers</code> method above was doing two things wrong; querying inefficiently for <em>all</em> the users in the system and then allocating large arrays to partition the data based on permissions. Once we understood the missing fundamental we had a path forward to try and optimize this poorly performing code: we should see if we can query things more efficiently. This is what we came up with using <code>async/await</code> and the MongoDB <a href="https://docs.mongodb.com/manual/aggregation/">aggregation pipeline</a>:</p>
<pre><code class="lang-javascript">getUsers: async <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span> </span>{
  <span class="hljs-keyword">const</span> adminUsers = await User.aggregate([
    {
      $match: {
        $or: [
          { <span class="hljs-string">"permissions.admin.corpUsers"</span> : { $eq: <span class="hljs-keyword">true</span> }},
          { <span class="hljs-string">"permissions.admin.techUsers"</span> : { $eq: <span class="hljs-keyword">true</span> }},
          { <span class="hljs-string">"permissions.admin.formalUsers"</span> : { $eq: <span class="hljs-keyword">true</span> }},
          { <span class="hljs-string">"permissions.admin.searchUser"</span> : { $eq: <span class="hljs-keyword">true</span> }},
          { <span class="hljs-string">"permissions.admin.superAdmin"</span> : { $eq: <span class="hljs-keyword">true</span> }},
        ]
      }
    }
  ])

  <span class="hljs-keyword">const</span> corpUsers = await User.aggregate([
    {
      $match: {
        <span class="hljs-string">"permissions.general.corpUsers"</span> : { $eq: <span class="hljs-keyword">true</span> }
      }
    }
  ])

  <span class="hljs-comment">// ... etc...</span>

  res.status(<span class="hljs-number">200</span>).json({
    data: {
      adminUsers,
      corpUsers,
      ...
    }
  })
}
</code></pre>
<p>Once we had re-written and tested the query to make sure the output was the same, we re-ran our performance profiling to see what the difference was.</p>
<pre><code class="lang-shell">PerformanceEntry {
  name: <span class="hljs-string">'getUsers to res.status(200)'</span>,
  entryType: <span class="hljs-string">'measure'</span>,
  startTime: 496079.094306,
  duration: 270.1256
}
The<span class="hljs-built_in"> script </span>uses ~ 44.550048828125 MB
</code></pre>
<p>Using the Aggregation pipeline had yielded an order of magnitude less memory and CPU usage! Here&#39;s a couple of screenshots from the Heroku dashboard for this app that show the before/after comparisons as well.</p>
<h3 id="before-request-timeouts-and-large-amounts-of-memory-consumption-">Before - request timeouts, and large amounts of memory consumption.</h3>
<p><img src="/img/the-missing-fundamental/before-30s-timeouts-large-ram-usage.png" alt="Before"></p>
<h3 id="after-no-timeouts-memory-consumption-reduced-by-a-factor-of-10-">After - no timeouts, memory consumption reduced by a factor of 10.</h3>
<p><img src="/img/the-missing-fundamental/after-2s-no-timeouts-50mb-ram-usage.png" alt="After"></p>
<h1 id="conclusions">Conclusions</h1>
<p>If you find yourself in a similar situation evaluating the performance of some legacy code I would encourage you to think about asking questions around what the missing fundamental(s) are. Walking through <strong>investigate</strong>, <strong>profile</strong>, <strong>identify</strong> (rinse. repeat.) has been useful for me, and I hope it is for you!</p>
<p>If you&#39;re interested in this type of work, you should reach out and <a href="mailto:hi@testdouble.com">say hi</a>; they&#39;re always looking to hire expert software engineers. :)</p>
</div></section></article><footer class="root">&copy; 2021 - David A. Mosher</footer></div><script type="text/javascript" src="/js/app.js"></script></body></html>